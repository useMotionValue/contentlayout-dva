---
title: t3 stack tutorial
description: Learn how to build a blog app with Next.js tRRC Zod.
date: 2023-4-5
author: useMotionValue 
---

![intro image](https://images.unsplash.com/photo-1542370285-b8eb8317691c?ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D&auto=format&fit=crop&w=1426&q=80)

# T3 Stack

## Zod

[github-repo](https://github.com/colinhacks/zod)

### Basic usage

```typescript
import { z } from "zod"

// creating a schema for strings
const mySchema = z.string()

// parsing
mySchema.parse("tuna") // => "tuna"
mySchema.parse(12) // => throws ZodError

// "safe" parsing (doesn't throw error if validation fails)
mySchema.safeParse("tuna") // => { success: true; data: "tuna" }
mySchema.safeParse(12) // => { success: false; error: ZodError }
```

ä½¿ç”¨`safeParse`æ–¹æ³•åšæ ¡éªŒæ›´å®‰å…¨ã€‚

å¯¹è±¡ç±»å‹çš„ shcemaï¼š

```typescript
const User = z.object({
  username: z.string()
})

User.parse({ username: "Ludwig" })
```

å¯ä»¥é€šè¿‡`z.infer`è·å¾— typescript çš„ç±»å‹ï¼š`type User = z.infer<typeof User>`

### Optionals

é€šè¿‡`z.optional()`æ¥å°† schema å˜æˆå¯é€‰çš„ï¼š

```typescript
const schema = z.optional(z.string())

schema.parse(undefined) // => returns undefined
type A = z.infer<typeof schema> // string | undefined
```

æˆ–è€…ï¼š

```typescript
const user = z.object({
  username: z.string().optional()
})
type C = z.infer<typeof user> // { username?: string | undefined };
```

å¯ä»¥ä½¿ç”¨`.upwrap()`æ–¹æ³•æ¥å–æ¶ˆå¯é€‰ï¼š

```typescript
const stringSchema = z.string()
const optionalString = stringSchema.optional()
optionalString.unwrap() === stringSchema // true
```

### Coercion

> è¿™é‡Œå…ˆä»‹ç»ä¸€ä¸‹`coerce`å’Œ`coecrion`

#### coerce å’Œ coecrion

coerce"å’Œ"coercion"æ˜¯è‹±è¯­ä¸­çš„ä¸¤ä¸ª
æœ¯è¯­ï¼Œè¡¨ç¤ºå°†ä¸€ç§ç±»å‹æˆ–å€¼è½¬æ¢ä¸ºå¦-
ç§ç±»å‹æˆ–å€¼çš„è¿‡ç¨‹ã€‚
"coerce "é€šå¸¸æŒ‡å°†ä¸€ä¸ªå€¼æˆ–å˜é‡ä»ä¸€ç§
ç±»å‹è½¬æ¢ä¸ºå¦ä¸€ç§ç±»å‹ï¼Œè¿™ç§è½¬æ¢é€šå¸¸
æ˜¯ç”±ç¼–ç¨‹è¯­è¨€æˆ–è®¡ç®—æœºç³»ç»Ÿè‡ªåŠ¨æ‰§è¡Œ
çš„ã€‚ä¾‹å¦‚ï¼Œåœ¨ Javascript ä¸­ï¼Œå½“ä¸€ä¸ªå­—
ç¬¦ä¸²ä¸ä¸€ä¸ªæ•°å­—ç›¸åŠ æ—¶ï¼ŒJavascript ä¼š
è‡ªåŠ¨å°†å­—ç¬¦ä¸²è½¬æ¢ä¸ºæ•°å­—ç±»å‹ï¼Œè¿™ä¸ªè¿‡
ç¨‹å°±å¯ä»¥ç§°ä¸º"coerce"
"coercion "åˆ™è¡¨ç¤ºæ‰§è¡Œ"coerce"è¿‡ç¨‹çš„
ç»“æœæˆ–æ•ˆæœã€‚ä¾‹å¦‚ï¼Œåœ¨ JavaScript ä¸­
å½“ä¸€ä¸ªå­—ç¬¦ä¸²ä¸ä¸€ä¸ªæ•°å­—ç›¸åŠ æ—¶ï¼Œ
JavaScript ä¼šè‡ªåŠ¨å°†å­—ç¬¦ä¸²è½¬æ¢ä¸ºæ•°å­—
ç±»å‹ï¼Œè¿™ä¸ªè½¬æ¢çš„ç»“æœå°±å¯ä»¥ç§°
ä¸º"coercion".
æ€»çš„æ¥è¯´ï¼Œ"coerce"å’Œ"coercion"è¿™ä¸¤
ä¸ªæœ¯è¯­éƒ½è¡¨ç¤ºå°†ä¸€ç§ç±»å‹æˆ–å€¼è½¬æ¢ä¸ºå¦
ä¸€ç§ç±»å‹æˆ–å€¼çš„è¿‡ç¨‹ï¼Œåªæ˜¯ä¸€ä¸ªè¡¨ç¤ºè¿‡
ç¨ˆä¸€ä¸ªè¡¨ç¤ºç»“æœã€‚

#### coecrion å’Œ type casting çš„åŒºåˆ«

"coercion"å’Œ"type
casting"éƒ½è¡¨ç¤ºå°†ä¸€ä¸ªå€¼ä»ä¸€ç§ç±»å‹è½¬
æ¢ä¸ºå¦ä¸€ç§ç±»å‹çš„è¿‡ç¨‹ï¼Œä½†æ˜¯å®ƒä»¬çš„å®
ç°æ–¹å¼å’Œè¯­ä¹‰ç•¥æœ‰ä¸åŒ
"Coercion"æ˜¯æŒ‡å°†ä¸€ä¸ªå€¼ä»ä¸€ç§ç±»å‹è½¬
æ¢ä¸ºå¦ä¸€ç§ç±»å‹çš„è¿‡ç¨‹ï¼Œè¿™ä¸ªè¿‡ç¨‹é€šå¸¸
æ˜¯ç”±ç¨‹åºè‡ªåŠ¨æ‰§è¡Œçš„ã€‚åœ¨è¿™ä¸ªè¿‡ç¨‹ä¸­
ç¨‹åºä¼šå°è¯•æ ¹æ®ä¸Šä¸‹æ–‡å’Œç±»å‹ä¹‹é—´çš„å…³
ç³»æ¥ç¡®å®šå¦‚ä½•è¿›è¡Œè½¬æ¢ã€‚ä¾‹å¦‚ï¼Œåœ¨
Javascript ä¸­ï¼Œå½“ä¸€ä¸ªå­—ç¬¦ä¸²ä¸ä¸€ä¸ªæ•°
å­—ç›¸åŠ æ—¶ï¼Œç¨‹åºä¼šè‡ªåŠ¨å°†å­—ç¬¦ä¸²è½¬æ¢ä¸º
æ•°å­—ç±»å‹ï¼Œè¿™ä¸ªè¿‡ç¨‹å°±æ˜¯"coercion"
"Type casting"åˆ™æ˜¯æŒ‡å°†ä¸€ä¸ªå€¼ä»ä¸€ç§
ç±»å‹è½¬æ¢ä¸ºå¦ä¸€ç§ç±»å‹çš„æ˜¾å¼æ“ä½œï¼Œè¿™
ä¸ªæ“ä½œé€šå¸¸ç”±ç¨‹åºå‘˜æ˜¾å¼åœ°ç¼–å†™ä»£ç æ¥
å®ç°ã€‚åœ¨è¿™ä¸ªè¿‡ç¨‹ä¸­ï¼Œç¨‹åºå‘˜éœ€è¦æŒ‡å®š
è¦è½¬æ¢çš„ç±»å‹å’Œè½¬æ¢çš„æ–¹å¼ã€‚ä¾‹å¦‚ï¼Œåœ¨
Java ä¸­ï¼Œå¯ä»¥ä½¿ç”¨å¼ºåˆ¶ç±»å‹è½¬æ¢æ“ä½œç¬¦
å°†ä¸€ä¸ªæ•°å­—ç±»å‹è½¬æ¢ä¸ºæ•´å‹ï¼Œè¿™ä¸ªæ“ä½œ
å°±æ˜¯"type casting"
æ€»çš„æ¥è¯´ï¼Œ
"coercion"å’Œ"type
casting"éƒ½è¡¨ç¤ºå°†ä¸€ä¸ªå€¼ä»ä¸€ç§ç±»å‹è½¬
æ¢ä¸ºå¦ä¸€ç§ç±»å‹çš„è¿‡ç¨‹ï¼Œä½†
æ˜¯"coercion"é€šå¸¸æ˜¯è‡ªåŠ¨æ‰§è¡Œçš„
è€Œ"type casting"åˆ™æ˜¯ç”±ç¨‹åºå‘˜æ˜¾å¼ç¼–å†™
çš„æ“ä½œã€‚æ­¤å¤–ï¼Œç”±äº"coercion"æ˜¯è‡ªåŠ¨
æ‰§è¡Œçš„ï¼Œå¯èƒ½ä¼šå¯¼è‡´ä¸€äº›æ„å¤–çš„é—®é¢˜ï¼Œ
å› æ­¤ç¨‹åºå‘˜éœ€è¦æ³¨æ„ç±»å‹ä¹‹é—´çš„å…³ç³»å’Œè½¬æ¢çš„è¿‡ç¨‹ã€‚

#### Zod ä¸­çš„ coecrion

```typescript
const schema = z.coerce.string()
schema.parse("tuna") // => "tuna"
schema.parse(12) // => "12"
schema.parse(true) // => "true"
```

coercing ä¹‹åçš„æ•°æ®ä¸º`ZodString`,å¯ä»¥ä½¿ç”¨`z.string()`çš„æ–¹æ³•ï¼š`z.coerce.string().email().min(5);`

### Literals

> `Literals`å³å­—é¢é‡ç±»å‹ï¼Œç®€å•è€Œç›´æ¥åœ°è¡¨ç¤ºç‰¹å®šçš„å€¼ã€‚

```typescript
const tuna = z.literal("tuna")
const twelve = z.literal(12)
const twobig = z.literal(2n) // bigint literal
const tru = z.literal(true)

const terrificSymbol = Symbol("terrific")
const terrific = z.literal(terrificSymbol)

// retrieve literal value
tuna.value // "tuna"
```

### String

`z.string()`æœ‰è®¸å¤šå¥½ç”¨çš„æ ¡éªŒï¼Œå¦‚ uuid, regexï¼Œipï¼Œemail ç­‰ï¼š

```typescript
// validations
z.string().max(5)
z.string().min(5)
z.string().length(5)
z.string().email()
z.string().url()
z.string().emoji()
z.string().uuid()
z.string().cuid()
z.string().cuid2()
z.string().ulid()
z.string().regex(regex)
z.string().includes(string)
z.string().startsWith(string)
z.string().endsWith(string)
z.string().datetime() // defaults to UTC, see below for options
z.string().ip() // defaults to IPv4 and IPv6, see below for options

// transformations
z.string().trim() // trim whitespace
z.string().toLowerCase() // toLowerCase
z.string().toUpperCase() // toUpperCase
```

åœ¨åˆ›å»º`string schema`æ—¶ï¼Œå¯ä»¥è‡ªå®šä¹‰`error messages`

```typescript
const name = z.string({
  required_error: "Name is required",
  invalid_type_error: "Name must be a string"
})
```

æˆ–è€…åœ¨ä½¿ç”¨æ ¡éªŒæ–¹æ³•æ—¶ï¼Œé€šè¿‡ä¼ å…¥å‚æ•°çš„å½¢å¼è‡ªå®šä¹‰æ ¡éªŒ`error messages`

```typescript
z.string().min(5, { message: "Must be 5 or more characters long" })
z.string().max(5, { message: "Must be 5 or fewer characters long" })
z.string().length(5, { message: "Must be exactly 5 characters long" })
z.string().email({ message: "Invalid email address" })
z.string().url({ message: "Invalid url" })
z.string().emoji({ message: "Contains non-emoji characters" })
z.string().uuid({ message: "Invalid UUID" })
z.string().includes("tuna", { message: "Must include tuna" })
z.string().startsWith("https://", { message: "Must provide secure URL" })
z.string().endsWith(".com", { message: "Only .com domains allowed" })
z.string().datetime({ message: "Invalid datetime string! Must be UTC." })
z.string().ip({ message: "Invalid IP address" })
```

### Zod enums

`z.enum`å£°æ˜`string`ç±»å‹çš„`enum schema`

```typescript
const FishEnum = z.enum(["Salmon", "Tuna", "Trout"])
type FishEnum = z.infer<typeof FishEnum>
// 'Salmon' | 'Tuna' | 'Trout'
```

æˆ–è€…ä½¿ç”¨ typesc çš„ const æ–­è¨€å°†å­—ç¬¦ä¸²æ•°ç»„ä½œä¸ºå‚æ•°ä¼ å…¥`z.enum`,`as const`å°†æšä¸¾å€¼å®šä¹‰ä¸ºå­—ç¬¦ä¸²`tuple`å…ƒç»„

```typescript
const VALUES = ["Salmon", "Tuna", "Trout"] as const
const FishEnum = z.enum(VALUES)
```

ç›¸å¯¹åº”åœ°ï¼Œå¯ä»¥å°†ä¸Šè¿°`z.enum`åˆ›å»ºçš„`enum schema`è½¬ä¸ºæ•°ç»„ï¼š

```typescript
FishEnum.options // ["Salmon", "Tuna", "Trout"];
```

### Native enums

ç”¨äºæ ¡éªŒç¬¬ä¸‰æ–¹åº“çš„ enums æˆ–è€…è‡ªå·±å®šä¹‰çš„ enums ç­‰åœºæ™¯ï¼Œå¯ä»¥ä½¿ç”¨`z.nativeEnum()`

```typescript
enum Fruits {
  Apple = "apple",
  Banana = "banana",
  Cantaloupe // you can mix numerical and string enums
}

const FruitEnum = z.nativeEnum(Fruits)
type FruitEnum = z.infer<typeof FruitEnum> // Fruits

FruitEnum.parse(Fruits.Apple) // passes
FruitEnum.parse(Fruits.Cantaloupe) // passes
FruitEnum.parse("apple") // passes
FruitEnum.parse("banana") // passes
FruitEnum.parse(0) // passes
FruitEnum.parse("Cantaloupe") // fails
```

## trpc

### Quickstart

#### backend

initialize

```typescript
import { initTRPC } from "@trpc/server"
/**
 * Initialization of tRPC backend
 * Should be done only once per backend!
 */
const t = initTRPC.create()
/**
 * Export reusable router and procedure helpers
 * that can be used throughout the router
 */
export const router = t.router
export const middleware = t.middleware
export const publicProcedure = t.procedure
```

initialize router instance, å¯¼å‡ºçš„`AppRouter` type å¯ä»¥ä¾› client ç«¯ç”¨ã€‚

```typescript
import { router } from "./trpc"
const appRouter = router({
  // èšåˆå¤šä¸ªrouter
  // ä¹Ÿå¯ä»¥å†™æˆï¼šconst appRouter = mergeRouters(userRouter, postRouter)
  // ...
})
// Export type router type signature,
// NOT the router itself.
export type AppRouter = typeof appRouter
```

å†™ä¸€ä¸ª query çš„æ¥å£ï¼š

```typescript
import { db } from "./db"
import { publicProcedure, router } from "./trpc"
const appRouter = router({
  // ä½¿ç”¨zodæ¥é™åˆ¶å‚æ•°ç±»å‹
  userList: publicProcedure.input(z.string()).query(async () => {
    // Retrieve users from a datasource, this is an imaginary database
    const users = await db.user.findMany()
    return users
  })
})
```

å†™ä¸€ä¸ª mutation æ¥å£ï¼š

```typescript
const appRouter = router({
  // ...
  userCreate: publicProcedure
    .input(z.object({ name: z.string() }))
    .mutation(async opts => {
      const { input } = opts
      // Create a new user in the database
      const user = await db.user.create(input)
      return user
    })
})
```

å¯åŠ¨åç«¯æœåŠ¡ï¼š
åœ¨æˆ‘ä»¬å®šä¹‰äº† server ç«¯çš„ router åï¼Œå¯ä»¥ä½¿ç”¨ trpc æä¾›çš„è®¸å¤š [adapters](https://trpc.io/docs/server/adapters)ï¼Œå¦‚ä¸º`express`æä¾›çš„ `adapter`ã€`nextjs`æä¾›çš„`adapter`

è¿™é‡Œä½¿ç”¨`Standalone adapter`, æ˜¯ trpc server çš„å•ç‹¬é€‚é…å™¨ï¼Œæ˜¯æ­å»º app æœ€ç®€å•çš„æ–¹å¼ã€‚

```typescript
import { createHTTPServer } from "@trpc/server/adapters/standalone"
const appRouter = router({
  // ...
})
const server = createHTTPServer({
  router: appRouter
  // middleware: cors(),
  // createContext() {},
})
server.listen(3000)
```

#### frontend

å¯¼å…¥åç«¯å®šä¹‰çš„`AppRouter` type å¹¶ä¸”ä½œä¸ºæ³›å‹ä¼ ç»™`createTRPCProxyClient`

```typescript
import { createTRPCProxyClient, httpBatchLink } from "@trpc/client"
import type { AppRouter } from "./server"
//     ğŸ‘† **type-only** import
// Pass AppRouter as generic here. ğŸ‘‡ This lets the `trpc` object know
// what procedures are available on the server and their input/output types.
const trpc = createTRPCProxyClient<AppRouter>({
  links: [
    httpBatchLink({
      url: "http://localhost:3000"
    })
  ]
})
```

Querying & Mutating

```typescript
// Inferred types
const user = await trpc.userById.query("1")
const createdUser = await trpc.userCreate.mutate({ name: "sachinraja" })
```

### Backend Advanced usage

#### initialize

`t`object å¯ä»¥é€šè¿‡å‡½æ•°çš„é“¾å¼è°ƒç”¨æ¥åˆå§‹åŒ–ï¼š

```typescript
const t = initTRPC.context<Context>().meta<Meta>().create({
  /* [...] */
})

#### RuntimeConfig
export interface RuntimeConfig<TTypes extends RootConfigTypes> {
  /**
   * Use a data transformer
   * @link https://trpc.io/docs/data-transformers
   */
  transformer: TTypes['transformer'];

  /**
   * Use custom error formatting
   * @link https://trpc.io/docs/error-formatting
   */
  errorFormatter: ErrorFormatter<TTypes['ctx'], any>;

  /**
   * Allow `@trpc/server` to run in non-server environments
   * @warning **Use with caution**, this should likely mainly be used within testing.
   * @default false
   */
  allowOutsideOfServer: boolean;

  /**
   * Is this a server environment?
   * @warning **Use with caution**, this should likely mainly be used within testing.
   * @default typeof window === 'undefined' || 'Deno' in window || process.env.NODE_ENV === 'test'
   */
  isServer: boolean;

  /**
   * Is this development?
   * Will be used to decide if the API should return stack traces
   * @default process.env.NODE_ENV !== 'production'
   */
  isDev: boolean;
}
```

#### Input & Output Validators

##### Input merging

å¯ä»¥åœ¨ä¸­é—´ä»¶åˆ©ç”¨ä¸€äº› common inputï¼Œä½¿å¾—`z.input()`å¯ä»¥å †å ä»¥æ„å»ºæ›´å¤æ‚çš„ç±»å‹ã€‚

```typescript
// è¿™ä¸ªbaseProcedure ä¸ºä¸­é—´ä»¶,inputçš„ç±»å‹ä¼šè¢«å †å 
const baseProcedure = t.procedure
  .input(z.object({ townName: z.string() }))
  .use(opts => {
    const input = opts.input
    console.log(`Handling request with user from: ${input.townName}`)
    return opts.next()
  })

export const appRouter = t.router({
  hello: baseProcedure
    .input(
      z.object({
        name: z.string()
      })
    )
    .query(opts => {
      const input = opts.input // input: {name: string, townName: stirng}
      return {
        greeting: `Hello ${input.name}, my friend from ${input.townName}`
      }
    })
})
```

##### Output Validators

```typescript
export const appRouter = t.router({
  hello: publicProcedure
    .output(
      z.object({
        greeting: z.string()
      })
    )
    .query(opts => {
      return {
        gre // è¿™é‡ŒLSPä¼šæç¤ºï¼šgreeting
      }
    })
})
```

#### Context

context ä¸Šä¸‹æ–‡ä¿å­˜äº†æ‰€æœ‰ tRPC è¿‡ç¨‹éƒ½å¯ä»¥è®¿é—®çš„æ•°æ®ï¼Œæ˜¯æ”¾ç½®æ•°æ®åº“è¿æ¥æˆ–èº«ä»½éªŒè¯ä¿¡æ¯ç­‰å†…å®¹çš„å¥½åœ°æ–¹ã€‚

##### å®šä¹‰ context ç±»å‹

åœ¨ä½¿ç”¨`initTRPC`åˆå§‹åŒ–æ—¶ï¼Œåœ¨è°ƒç”¨`.create()`å‰ï¼Œä½¿ç”¨`.context<TContext>()`å’Œå®šä¹‰çš„ createContext å‡½æ•°ä¼ é€’ç»™`initTRPC`ï¼Œæ¥ä½¿å¾—ä¹‹åçš„`procedures`éƒ½èƒ½è·å¾— context çš„ç±»å‹ã€‚

```typescript
import { initTRPC, type inferAsyncReturnType } from '@trpc/server';
import type { CreateNextContextOptions } from '@trpc/server/adapters/next';
import { getSession } from 'next-auth/react';
Â 
export const createContext = async (opts: CreateNextContextOptions) => {
  const session = await getSession({ req: opts.req });
Â 
  return {
    session,
  };
};
Â 
const t1 = initTRPC.context<typeof createContext>().create();
t1.procedure.use(({ ctx }) => { ... });
Â 
type Context = inferAsyncReturnType<typeof createContext>;
const t2 = initTRPC.context<Context>().create();
t2.procedure.use(({ ctx }) => { ... });
```

##### Inner and outer context

åœ¨æŸäº›æƒ…å†µä¸‹ï¼Œå°† context åˆ†æˆâ€œå†…éƒ¨â€å’Œâ€œå¤–éƒ¨â€å‡½æ•°å¯èƒ½æ˜¯æœ‰æ„ä¹‰çš„ã€‚

å†…éƒ¨ context æ˜¯æ‚¨å®šä¹‰ä¸ä¾èµ–äºè¯·æ±‚çš„ context çš„åœ°æ–¹ï¼Œä¾‹å¦‚æ•°æ®åº“è¿æ¥ã€‚æ‚¨å¯ä»¥åœ¨é›†æˆæµ‹è¯•æˆ–æœåŠ¡å™¨ç«¯åŠ©æ‰‹ä¸­ä½¿ç”¨æ­¤åŠŸèƒ½ï¼Œåœ¨è¿™äº›åœºæ™¯ä¸­æ²¡æœ‰è¯·æ±‚å¯¹è±¡ã€‚æ— è®ºä½•æ—¶å®šä¹‰äº†ä»€ä¹ˆå†…å®¹éƒ½å°†å§‹ç»ˆå¯ç”¨äºæ‚¨çš„è¿‡ç¨‹ã€‚

å¤–éƒ¨ context æ˜¯æ‚¨å®šä¹‰ä¾èµ–äºè¯·æ±‚çš„ context çš„åœ°æ–¹ï¼Œä¾‹å¦‚ç”¨æˆ·ä¼šè¯ã€‚åœ¨æ­¤å¤„å®šä¹‰çš„ä»»ä½•å†…å®¹ä»…é€‚ç”¨äºé€šè¿‡ HTTP è°ƒç”¨çš„è¿‡ç¨‹ã€‚

```typescript
import type { inferAsyncReturnType } from "@trpc/server"
import type { CreateNextContextOptions } from "@trpc/server/adapters/next"
import { getSessionFromCookie, type Session } from "./auth"

/**
 * Defines your inner context shape.
 * Add fields here that the inner context brings.
 */
interface CreateInnerContextOptions extends Partial<CreateNextContextOptions> {
  session: Session | null
}

/**
 * Inner context. Will always be available in your procedures, in contrast to the outer context.
 *
 * Also useful for:
 * - testing, so you don't have to mock Next.js' `req`/`res`
 * - tRPC's `createServerSideHelpers` where we don't have `req`/`res`
 *
 * @see https://trpc.io/docs/context#inner-and-outer-context
 */
export async function createContextInner(opts?: CreateInnerContextOptions) {
  return {
    prisma,
    session: opts.session
  }
}

/**
 * Outer context. Used in the routers and will e.g. bring `req` & `res` to the context as "not `undefined`".
 *
 * @see https://trpc.io/docs/context#inner-and-outer-context
 */
export async function createContext(opts: CreateNextContextOptions) {
  const session = getSessionFromCookie(opts.req)

  const contextInner = await createContextInner({ session })

  return {
    ...contextInner,
    req: opts.req,
    res: opts.res
  }
}

export type Context = inferAsyncReturnType<typeof createContextInner>

// The usage in your router is the same as the example above.
```

#### Middlewares

å¯ä»¥ä½¿ç”¨ `t.procedure.use()` æ–¹æ³•å‘è¿‡ç¨‹æ·»åŠ ä¸­é—´ä»¶ã€‚è¿™äº›ä¸­é—´ä»¶å°†åŒ…è£… procedure çš„è°ƒç”¨ï¼Œå¹¶å¿…é¡»ä¼ å‡ºå…¶è¿”å›å€¼ã€‚

##### isAuthed protector middleware showcase

```typescript
// -------------------------------------------------
// @filename: context.ts
// -------------------------------------------------
import type { inferAsyncReturnType } from "@trpc/server"
import type { CreateNextContextOptions } from "@trpc/server/adapters/next"
import { getSession } from "next-auth/react"
/**
 * Creates context for an incoming request
 * @link https://trpc.io/docs/context
 */
export async function createContext(opts: CreateNextContextOptions) {
  const session = await getSession({ req: opts.req })
  return {
    session
  }
}
export type Context = inferAsyncReturnType<typeof createContext>
// -------------------------------------------------
// @filename: trpc.ts
// -------------------------------------------------
import { initTRPC, TRPCError } from "@trpc/server"
import { Context } from "./context"
const t = initTRPC.context<Context>().create()
const isAuthed = t.middleware(({ next, ctx }) => {
  if (!ctx.session?.user?.email) {
    throw new TRPCError({
      code: "UNAUTHORIZED"
    })
  }
  return next({
    ctx: {
      // Infers the `session` as non-nullable
      session: ctx.session
    }
  })
})
export const middleware = t.middleware
export const router = t.router
/**
 * Unprotected procedure
 */
export const publicProcedure = t.procedure
/**
 * Protected procedure
 */
export const protectedProcedure = t.procedure.use(isAuthed)
```

##### logger middleware showcase

```typescript
const loggerMiddleware = middleware(async opts => {
  const start = Date.now()
  const result = await opts.next()
  const durationMs = Date.now() - start
  const meta = { path: opts.path, type: opts.type, durationMs }
  result.ok
    ? console.log("OK request timing:", meta)
    : console.error("Non-OK request timing", meta)
  return result
})
export const loggedProcedure = publicProcedure.use(loggerMiddleware)
```

##### Context extension middleware

Context Extension å¯ä»¥è®©ä¸­é—´ä»¶ä»¥ç±»å‹å®‰å…¨çš„æ–¹å¼åŠ¨æ€åœ°æ·»åŠ å’Œè¦†ç›–åŸºæœ¬ç¨‹åº context ä¸­çš„ key

```typescript
type Context = {
  // user is nullable
  user?: {
    id: string
  }
}
const isAuthed = middleware(opts => {
  const { ctx } = opts
  // `ctx.user` is nullable
  if (!ctx.user) {
    throw new TRPCError({ code: "UNAUTHORIZED" })
  }
  return opts.next({
    ctx: {
      // âœ… user value is known to be non-null now
      user: ctx.user
    }
  })
})
const protectedProcedure = publicProcedure.use(isAuthed)
protectedProcedure.query(({ ctx }) => ctx.user)
```

##### Extending Middlewares

ä½¿ç”¨`.pipe()`æ¥ extend middleware

```typescript
const fooMiddleware = middleware(opts => {
  return opts.next({
    ctx: {
      foo: "foo" as const
    }
  })
})
const barMiddleware = fooMiddleware.unstable_pipe(opts => {
  const { ctx } = opts
  ctx.foo
  return opts.next({
    ctx: {
      bar: "bar" as const
    }
  })
})
const barProcedure = publicProcedure.use(barMiddleware)
barProcedure.query(({ ctx }) => ctx.bar) // è¿™é‡Œctxèƒ½æ‹¿åˆ°barå’Œfoo
```

#### Next.js adapter

åœ¨ nextjs ä¸­ä½¿ç”¨ trpcï¼Œéœ€è¦åœ¨ç›®å½•`pages/api/trpc/[trpc].ts`ä¸­åˆ›å»ºä¸€ä¸ª API handler æ–‡ä»¶:

```typescript
import { createNextApiHandler } from "@trpc/server/adapters/next"
import { createContext } from "../../../server/trpc/context"
import { appRouter } from "../../../server/trpc/router/_app"

// @see https://nextjs.org/docs/api-routes/introduction
export default createNextApiHandler({
  router: appRouter,
  createContext
})
```

##### å¤„ç† CORS ç­‰

```typescript
import { createNextApiHandler } from "@trpc/server/adapters/next"
import { createContext } from "../../../server/trpc/context"
import { appRouter } from "../../../server/trpc/router/_app"

// create the API handler, but don't return it yet
const nextApiHandler = createNextApiHandler({
  router: appRouter,
  createContext
})

// @see https://nextjs.org/docs/api-routes/introduction
export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  // We can use the response object to enable CORS
  res.setHeader("Access-Control-Allow-Origin", "*")
  res.setHeader("Access-Control-Request-Method", "*")
  res.setHeader("Access-Control-Allow-Methods", "OPTIONS, GET")
  res.setHeader("Access-Control-Allow-Headers", "*")

  // If you need to make authenticated CORS calls then
  // remove what is above and uncomment the below code

  // Allow-Origin has to be set to the requesting domain that you want to send the credentials back to
  // res.setHeader('Access-Control-Allow-Origin', 'http://example:6006');
  // res.setHeader('Access-Control-Request-Method', '*');
  // res.setHeader('Access-Control-Allow-Methods', 'OPTIONS, GET');
  // res.setHeader('Access-Control-Allow-Headers', 'content-type');
  // res.setHeader('Referrer-Policy', 'no-referrer');
  // res.setHeader('Access-Control-Allow-Credentials', 'true');

  if (req.method === "OPTIONS") {
    res.writeHead(200)
    return res.end()
  }

  // finally pass the request on to the tRPC handler
  return nextApiHandler(req, res)
}
```

#### Server Side Calls

å½“æƒ³è¦ä»æ‰˜ç®¡ procedures çš„åŒä¸€ä¸ª server å†…è°ƒç”¨ procedure æ—¶ï¼Œå¯ä»¥ä½¿ç”¨`router.createCaller({})`, ç¬¬ä¸€ä¸ªå‚æ•°æ˜¯ Context

ä½¿ç”¨ caller è·å– query ç»“æœï¼š

```typescript
import { initTRPC } from "@trpc/server"
import { z } from "zod"
const t = initTRPC.create()
const router = t.router({
  // Create procedure at path 'greeting'
  greeting: t.procedure
    .input(z.object({ name: z.string() }))
    .query(opts => `Hello ${opts.input.name}`)
})
const caller = router.createCaller({})
const result = await caller.greeting({ name: "tRPC" })
```

åœ¨è°ƒç”¨éœ€è¦ context å€¼çš„ procedure æ—¶ï¼Œéœ€è¦ç»™ caller ä¼ å…¥å‚æ•°ã€‚

#### Authorization

##### Create context from request headers

```typescript
import * as trpc from "@trpc/server"
import { inferAsyncReturnType } from "@trpc/server"
import * as trpcNext from "@trpc/server/adapters/next"
import { decodeAndVerifyJwtToken } from "./somewhere/in/your/app/utils"

export async function createContext({
  req,
  res
}: trpcNext.CreateNextContextOptions) {
  // Create your context based on the request object
  // Will be available as `ctx` in all your resolvers

  // This is just an example of something you might want to do in your ctx fn
  async function getUserFromHeader() {
    if (req.headers.authorization) {
      const user = await decodeAndVerifyJwtToken(
        req.headers.authorization.split(" ")[1]
      )
      return user
    }
    return null
  }
  const user = await getUserFromHeader()

  return {
    user
  }
}
export type Context = inferAsyncReturnType<typeof createContext>
```

##### Option 1: Authorize using resolver

```typescript
import { TRPCError, initTRPC } from "@trpc/server"
import type { Context } from "../context"

export const t = initTRPC.context<Context>().create()

const appRouter = t.router({
  // open for anyone
  hello: t.procedure
    .input(z.string().nullish())
    .query(opts => `hello ${opts.input ?? opts.ctx.user?.name ?? "world"}`),
  // checked in resolver
  secret: t.procedure.query(opts => {
    if (!opts.ctx.user) {
      throw new TRPCError({ code: "UNAUTHORIZED" })
    }
    return {
      secret: "sauce"
    }
  })
})
```

##### Option 2: Authorize using middleware

```typescript
import { TRPCError, initTRPC } from "@trpc/server"

export const t = initTRPC.context<Context>().create()

const isAuthed = t.middleware(opts => {
  const { ctx } = opts
  if (!ctx.user?.isAdmin) {
    throw new TRPCError({ code: "UNAUTHORIZED" })
  }
  return opts.next({
    ctx: {
      user: ctx.user
    }
  })
})

// you can reuse this for any procedure
export const protectedProcedure = t.procedure.use(isAuthed)

t.router({
  // this is accessible for everyone
  hello: t.procedure
    .input(z.string().nullish())
    .query(opts => `hello ${opts.input ?? opts.ctx.user?.name ?? "world"}`),
  admin: t.router({
    // this is accessible only to admins
    secret: protectedProcedure.query(opts => {
      return {
        secret: "sauce"
      }
    })
  })
})
```

#### Error Handling

å¯ä»¥ä½¿ç”¨ trpc æä¾›çš„ hepler å‡½æ•°ï¼š`getHTTPStatusCodeFromError`ï¼Œå¾—åˆ°å¯¹åº”çš„é”™è¯¯çŠ¶æ€ç ï¼š

```typescript
import { getHTTPStatusCodeFromError } from "@trpc/server/http"
// Example error you might get if your input validation fails
const error: TRPCError = {
  name: "TRPCError",
  code: "BAD_REQUEST",
  message: '"password" must be at least 4 characters'
}
if (error instanceof TRPCError) {
  const httpCode = getHTTPStatusCodeFromError(error)
  console.log(httpCode) // 400
}
```

å¯ä»¥é€šè¿‡`TRPCError`å­ç±»æ¥æŠ›å‡ºé”™è¯¯ï¼š

```typescript
import { TRPCError, initTRPC } from "@trpc/server"

const t = initTRPC.create()

const appRouter = t.router({
  hello: t.procedure.query(() => {
    throw new TRPCError({
      code: "INTERNAL_SERVER_ERROR",
      message: "An unexpected error occurred, please try again later.",
      // optional: pass the original error to retain stack trace
      cause: theError
    })
  })
})

// [...]
```

#### Error formatting

Adding custom formatting:

```typescript
import { initTRPC } from "@trpc/server"

export const t = initTRPC.context<Context>().create({
  errorFormatter(opts) {
    const { shape, error } = opts
    return {
      ...shape,
      data: {
        ...shape.data,
        zodError:
          error.code === "BAD_REQUEST" && error.cause instanceof ZodError
            ? error.cause.flatten()
            : null
      }
    }
  }
})
```

#### MetaData

> procedure metaData å¯ä»¥ä¸º procedure æ·»åŠ ç‰¹å®šçš„ meta å±æ€§ï¼Œè¿™äº›å±æ€§å°†ä¼šå‡ºç°åœ¨æ‰€æœ‰ middlewares å‚æ•°ä¸­ã€‚
>
> ä½¿ç”¨åœºæ™¯æ¯”å¦‚ä¸‹æ–‡ isAuthed middleware ä¸­ï¼Œå¦‚æœ procedure çš„ metaData ä¸º authRequired æ‰èµ°è¿™ä¸ª middleware çš„åˆ¤æ–­ã€‚

##### åˆ›å»º metaData

åˆ›å»ºå¸¦æœ‰ type çš„ metadataï¼š

```typescript
import { initTRPC } from "@trpc/server"

// [...]

interface Meta {
  authRequired: boolean
}

export const t = initTRPC.context<Context>().meta<Meta>().create()

export const appRouter = t.router({
  // [...]
})
```

routers:

```typescript
import { initTRPC } from "@trpc/server"

// [...]

interface Meta {
  authRequired: boolean
}

export const t = initTRPC.context<Context>().meta<Meta>().create()

const isAuthed = t.middleware(async opts => {
  const { meta, next, ctx } = opts
  // only check authorization if enabled
  if (meta?.authRequired && !ctx.user) {
    throw new TRPCError({ code: "UNAUTHORIZED" })
  }
  return next()
})

export const authedProcedure = t.procedure.use(isAuthed)

export const appRouter = t.router({
  hello: authedProcedure.meta({ authRequired: false }).query(() => {
    return {
      greeting: "hello world"
    }
  }),
  protectedHello: authedProcedure.meta({ authRequired: true }).query(() => {
    return {
      greeting: "hello-world"
    }
  })
})
```

##### default metaData å’Œ mergin metaData

```typescript
import { initTRPC } from '@trpc/server';

interface Meta {
  authRequired: boolean;
  role?: 'user' | 'admin'
}

export const t = initTRPC
  .context<Context>()
  .meta<Meta>()
  .create({
    // Set a default value
    defaultMeta: { authRequired: false }
  });

const publicProcedure = t.procedure
// ^ Default Meta: { authRequired: false }

const authProcedure = publicProcedure
  .use(authMiddleware)
  .meta({
    authRequired: true;
    role: 'user'
  });
// ^ Meta: { authRequired: true, role: 'user' }

const adminProcedure = authProcedure
  .meta({
    role: 'admin'
  });
// ^ Meta: { authRequired: true, role: 'admin' }
```

#### Response Caching

è¯¦è§[trpc docs](https://trpc.io/docs/server/caching)
åŸç†æ˜¯é€šè¿‡è®¾ç½® responseMetaï¼Œè®© vercel edge æ¥å®ç°ã€‚

```typescript
import { inferAsyncReturnType, initTRPC } from "@trpc/server"
import * as trpcNext from "@trpc/server/adapters/next"

export const createContext = async ({
  req,
  res
}: trpcNext.CreateNextContextOptions) => {
  return {
    req,
    res,
    prisma
  }
}

type Context = inferAsyncReturnType<typeof createContext>

export const t = initTRPC.context<Context>().create()

const waitFor = async (ms: number) =>
  new Promise(resolve => setTimeout(resolve, ms))

export const appRouter = t.router({
  public: t.router({
    slowQueryCached: t.procedure.query(async opts => {
      await waitFor(5000) // wait for 5s

      return {
        lastUpdated: new Date().toJSON()
      }
    })
  })
})

// Exporting type _type_ AppRouter only exposes types that can be used for inference
// https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-8.html#type-only-imports-and-export
export type AppRouter = typeof appRouter

// export API handler
export default trpcNext.createNextApiHandler({
  router: appRouter,
  createContext,
  responseMeta(opts) {
    const { ctx, paths, errors, type } = opts
    // assuming you have all your public routes with the keyword `public` in them
    const allPublic = paths && paths.every(path => path.includes("public"))
    // checking that no procedures errored
    const allOk = errors.length === 0
    // checking we're doing a query request
    const isQuery = type === "query"

    if (ctx?.res && allPublic && allOk && isQuery) {
      // cache request for 1 day + revalidate once every second
      const ONE_DAY_IN_SECONDS = 60 * 60 * 24
      return {
        headers: {
          "cache-control": `s-maxage=1, stale-while-revalidate=${ONE_DAY_IN_SECONDS}`
        }
      }
    }
    return {}
  }
})
```

### Data Trainsformers

> åºåˆ—åŒ– response data æˆ– input args
>
> Data Trainsformers éœ€è¦è¢«åŒæ—¶æ·»åŠ åˆ° server å’Œ client

#### ä½¿ç”¨`superjson`

> `superjson`å¯ä»¥åºåˆ—åŒ–`Date`, `Map`, `Set`ç­‰ã€‚

initTRPC:

```typescript
import { initTRPC } from "@trpc/server"
import superjson from "superjson"

export const t = initTRPC.create({
  transformer: superjson
})
```

åœ¨ nextjs client:

createTRPCProxyClient():

```typescript
import { createTRPCProxyClient } from "@trpc/client"
import superjson from "superjson"
import type { AppRouter } from "~/server/routers/_app"

export const client = createTRPCProxyClient<AppRouter>({
  transformer: superjson // <--
  // [...]
})
```

createTRPCNext():

```typescript
// -------------------------------------------------
// @filename: utils/trpc.ts
// -------------------------------------------------
import { createTRPCNext } from "@trpc/next"
import superjson from "superjson"
import type { AppRouter } from "~/server/routers/_app"

// [...]

export const trpc = createTRPCNext<AppRouter>({
  config({ ctx }) {
    return {
      transformer: superjson // <--
    }
  }
  // [...]
})
```

### NextJS Integration

ç›®å½•ç»“æ„ï¼š

```
.
â”œâ”€â”€ prisma # <-- if prisma is added
â”‚ â””â”€â”€ [..]
â”œâ”€â”€ src
â”‚ â”œâ”€â”€ pages
â”‚ â”‚ â”œâ”€â”€ \_app.tsx # <-- add `withTRPC()`-HOC here
â”‚ â”‚ â”œâ”€â”€ api
â”‚ â”‚ â”‚ â””â”€â”€ trpc
â”‚ â”‚ â”‚ â””â”€â”€ [trpc].ts # <-- tRPC HTTP handler
â”‚ â”‚ â””â”€â”€ [..]
â”‚ â”œâ”€â”€ server
â”‚ â”‚ â”œâ”€â”€ routers
â”‚ â”‚ â”‚ â”œâ”€â”€ \_app.ts # <-- main app router
â”‚ â”‚ â”‚ â”œâ”€â”€ post.ts # <-- sub routers
â”‚ â”‚ â”‚ â””â”€â”€ [..]
â”‚ â”‚ â”œâ”€â”€ context.ts # <-- create app context
â”‚ â”‚ â””â”€â”€ trpc.ts # <-- procedure helpers
â”‚ â””â”€â”€ utils
â”‚ â””â”€â”€ trpc.ts # <-- your typesafe tRPC hooks
â””â”€â”€ [..]
```

## NextAuth

## prisma

> [prisma.io](https://prisma.io)
>
> [prisma ä¸­æ–‡æ–‡æ¡£](https://prisma.yoga)

### ZenStack
